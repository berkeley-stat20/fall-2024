---
title: "Conditioning"
format: stat20slides-revealjs
execute:
  echo: true
---

# Concept Questions

:::{.notes}
This is a code heavy day, so it can be helpful to write up the names of the key dplyr verbs - mutate, arrange, select, filter, summarize, group_by - on side boards at the beginning when write short definitions as they come up. They can serve as references for the rest of the class period.

It can also be helpful to have RStudio open so that you can copy and paste from these cells into RStudio and run them.
:::

## 

```{r}
#| eval: false
c("fruit", "fruit", "vegetable") == "fruit"
```

:::{.poll}
What will this line of code return?
:::

{{< countdown "1:00" >}}


## Evaluating equivalence, cont.

In R, this evaluation happens element-wise when operating on vectors.

```{r}
#| eval: false

c("fruit", "fruit", "vegetable") == "fruit"
```

```{r}
#| echo: false
c("fruit", "fruit", "vegetable") == "fruit"
```

. . .

```{r fruit5, echo = TRUE, eval = FALSE}
c("fruit", "fruit", "vegetable") != "fruit"
```

. . .

```{r ref.label = "fruit5", echo = FALSE}
```

. . .

```{r fruit6, echo = TRUE, eval = FALSE}
c("fruit", "vegetable", "boba") %in% c("fruit", "vegetable")
```

. . .

```{r ref.label = "fruit6", echo = FALSE}
```

## Question 2

```{r}
#| echo: false
library(tidyverse)
library(stat20data)
```

```{r}
#| eval: false
class_survey |>
  filter(coding_exp_scale < 3,
         olympics %in% c("Ice skating", "Speed skating"),
         is_entrepreneur == TRUE)
```

:::{.poll}
Which observations will be included in the following data frame?
:::

{{< countdown "1:00" >}}

<!--
## Question 3: Opinion

10. What are studentsâ€™ perceptions of the chance that there is a new COVID variant that disrupts instruction in Spring 2023?

:::{.poll}
Do you think students in their first semester would be *more* likely or *less* likely to think we would remain in remote learning for the entire semester?

Answer at `pollev.com`.
:::

:::notes
Q: what is the comparison group: all students or students who are not in their first semester?
:::

-->

## Question 3

:::{.poll}
Which data frame will have fewer rows?
:::

. . .

```{r}
#| eval: false
#| echo: true
# A
filter(class_survey, time_at_cal == "This is my first semester!")

# B
class_survey |>
  mutate(first_sem = (time_at_cal == "This is my first semester!")) |>
  filter(first_sem)
```

{{< countdown "1:00" >}}


## Building data pipelines

Consider the subset of students here:

```{r}
#| eval: false
class_survey |>
  filter(coding_exp_scale < 3,
         olympics %in% c("Ice skating", "Speed skating"),
         is_entrepreneur == TRUE)
```

> How do we extract the average of these students' chance that class will be disrupted by a new COVID variant?


Let's look at three different ways to answer this question

## Nesting {auto-animate=true}


```{r}
#| eval: false
filter(class_survey, 
       coding_exp_scale < 3,
       olympics %in% c("Ice skating", "Speed skating"),
       is_entrepreneur == TRUE)
```

:::{.notes}
This set of slides walks through the three different approaches to stringing together functions in R, identifies the pros and cons of each, and encourages students to use the pipe.
:::


## Nesting {auto-animate=true}


```{r}
#| eval: false
select(filter(class_survey, 
       coding_exp_scale < 3,
       olympics %in% c("Ice skating", "Speed skating"),
       is_entrepreneur == TRUE),
       coding_exp_xcale,
       olympics,
       is_entrepreneur,
       covid)
```

## Nesting {auto-animate=true}


```{r}
#| eval: false
summarize(select(filter(class_survey, 
       coding_exp_scale < 3,
       olympics %in% c("Ice skating", "Speed skating"),
       is_entrepreneur == TRUE),
       coding_exp_scale,
       olympics,
       is_entrepreneur,
       covid),
       covid_avg = mean(covid))
```

## Nesting {auto-animate=true}

```{r}
summarize(select(filter(class_survey, 
       coding_exp_scale < 3,
       olympics %in% c("Ice skating", "Speed skating"),
       is_entrepreneur == TRUE),
       coding_exp_scale,
       olympics,
       is_entrepreneur,
       covid),
       covid_avg = mean(covid))
```


## Nesting

```{r}
#| eval: false
summarize(select(filter(class_survey, 
       coding_exp_scale < 3,
       olympics %in% c("Ice skating", "Speed skating"),
       is_entrepreneur == TRUE),
       coding_exp_scale,
       olympics,
       is_entrepreneur,
       covid),
       covid_avg = mean(covid))
```

. . .

:::: {.columns}

::: {.column width="50%"}
**Cons**

- Must be read from inside out `r emo::ji("thumbs_down")` 
- Hard to keep track of arguments `r emo::ji("thumbs_down")` 
:::

::: {.column width="50%"}
**Pros**

- All in one line of code `r emo::ji("thumbs_up")`
- Only refer to one data frame `r emo::ji("thumbs_up")`
:::

::::


## Step-by-step

. . .

```{r}
#| eval: false
df1 <- filter(class_survey, 
              coding_exp_scale < 3,
              olympics %in% c("Ice skating", "Speed skating"),
              is_entrepreneur == TRUE)
df2 <- select(df1, 
              coding_exp_scale,
              olympics,
              is_entrepreneur,
              covid)
summarize(df2,
          covid_avg = mean(covid))
```

. . .

:::: {.columns}

::: {.column width="50%"}
**Cons**

- Have to repeat data frame names `r emo::ji("thumbs_down")` 
- Creates unnecessary objects `r emo::ji("thumbs_down")` 
:::

::: {.column width="50%"}
**Pros**

- Stores intermediate objects `r emo::ji("thumbs_up")`
- Can be read top to bottom `r emo::ji("thumbs_up")`
:::

::::


##

![](images/pipeline-2.png)


## Using the pipe operator

. . .

```{r}
#| eval: false
class_survey |>
  filter(coding_exp_scale < 3,
         olympics %in% c("Ice skating", "Speed skating"),
         is_entrepreneur == TRUE) |>
  select(coding_exp_scale,
         olympics,
         is_entrepreneur,
         covid) |>
  summarize(covid_avg = mean(covid))
```

:::: {.columns}

::: {.column width="50%"}
**Cons**

- `r emo::ji("shrug")` 
:::

::: {.column width="50%"}
**Pros**

- Can be read like an english paragraph `r emo::ji("thumbs_up")`
- Only type the data once `r emo::ji("thumbs_up")`
- No leftovers objects `r emo::ji("thumbs_up")`
:::

::::

## Understanding your pipeline

. . .

It's good practice to understand the output of each line of code by *breaking the pipe*.

. . .

:::: {.columns}

::: {.column width="50%"}

```{r}
#| error: true
class_survey |>
  select(covid) |>
  filter(time_at_cal == "It's my first time_at_cal.")
```
:::

::: {.column width="50%"}
```{r}
class_survey |>
  select(covid)
```
:::

::::


## Concept Question

```{r}
#| eval: false
class_survey |> # A #<<
  filter(coding_exp_scale < 3,
         olympics %in% c("Ice skating", 
                         "Speed skating"),
         is_entrepreneur == TRUE) |> # B #<<
  select(coding_exp_scale,
         olympics,
         is_entrepreneur,
         covid) |> # C #<<
  summarize(covid_avg = mean(covid)) # D #<<
```

```{r}
# note
dim(class_survey)
```

:::{.poll}
What are the dimensions (rows x columns) of the data frames output at each stage of this pipe?
:::

{{< countdown "1:00" >}}


##

```{r}
#| eval: false
summarize(class_survey,
          mean(time_at_cal == "I'm in my first year.", na.rm = TRUE))
```

:::{.poll}
What is will this line of code return?
:::

{{< countdown "1:00" >}}

:::{.notes}
This will return the *proportion* of students who answered "I'm in my first year". This is surprising to students because it's not immediately clear that a mean of a logical vector is the same as the proportion of cases that are true.
::


## Boolean Algebra

Logical vectors have a dual representation as `TRUE` `FALSE` and `1`, `0`, so you can do math on logicals accordingly.

```{r}
TRUE + TRUE
```

. . .

```{r}
TRUE * TRUE
```

. . .

> Taking the mean of a logical vector is equivalent to find the proportion of rows that are `TRUE` (i.e. the proportion of rows that meet the condition).

# Worksheet: Conditioning

{{< countdown "20:00" >}}

# Break

{{< countdown "5:00" >}}

# Lab Part I: Flights

{{< countdown "25:00" >}}